# -*- coding: utf-8 -*-
"""trading_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11my5Og8Ob1eAsm2Vz0p2DU4oGqocRQTT

# **imports and variables:**
"""

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

!pip install plotly
import plotly.graph_objects as go

sp100 = [
    "AAPL", "ABBV", "ABT", "ACN", "ADBE", "AIG", "AMD", "AMGN", "AMT", "AMZN",
    "ANET", "APA", "APD", "AVGO", "AXP", "BA", "BAC", "BIIB", "BK", "BKNG",
    "BLK", "BMY", "BSX", "C", "CAT", "CHTR", "CL", "CMCSA", "COF", "COP",
    "COST", "CRM", "CSCO", "CVS", "CVX", "DHR", "DIS", "DOW", "DUK", "EMR",
    "EXC", "F", "FDX", "GD", "GE", "GILD", "GM", "GOOG", "GOOGL", "GS",
    "HON", "IBM", "INTC", "JNJ", "JPM", "KO", "LIN", "LLY", "LMT", "LOW",
    "MA", "MAR", "MCD", "MDLZ", "MDT", "MET", "MMM", "MO", "MRK", "MS",
    "MSFT", "NEE", "NFLX", "NKE", "NVDA", "ORCL", "PEP", "PFE", "PG", "PM",
    "PYPL", "QCOM", "RTX", "SBUX", "SCHW", "SO", "SPG", "T", "TGT", "TMO",
    "TMUS", "TSLA", "TXN", "UNH", "UNP", "UPS", "USB", "V", "VZ", "WBA",
    "WFC", "WMT", "XOM"
]

"""# **Functions:**"""

#takes a df and creates new columns that checks if the current 'High' price is higher than certain SMAs
def sma_filtering(df):
  filt20 = df["SMA20"] < df["High"]
  filt50 = df["SMA50"] < df["High"]
  filt100 = df["SMA100"] < df["High"]
  df["SMA20_Above"] = filt20
  df["SMA50_Above"] = filt50
  df["SMA100_Above"] = filt100
  df["above_avg"] = filt20 & filt50 & filt100
  return df

#takes as an input a stock name and period and returns the stock's df.
def stock_df(stock, period):
  dat = yf.Ticker(stock)
  df = dat.history(period=period).reset_index()
  df = df.loc[:, ['Date', 'Open', 'High', 'Low', 'Close']]
  return df

# takes a given stock and iterates over 'bunch-size" stocks at a time,
# applying 'func' to each bunch independantly
def iter(stock, bunch_size, func=None):
  i=0

  #taking the stock and converting it to a df.
  if type(stock) == str:
    cur_stock_df = stock_df(stock, '1y')
  elif type(stock) == pd.DataFrame:
    cur_stock_df = stock
  else:
    return 'not a valid dataFrame'

  #iterating while the bunch size equals the 'cur_bunch'
  #if they are not equal, it means we are on the last portion and we need to stop after this one.
  while True:
    cur_bunch = cur_stock_df.iloc[i:i+bunch_size, :]
    if len(cur_bunch) < bunch_size:
      break
    #if the user entered a function, apply it for each bunch.
    if func==bunch_mean:
      func(cur_stock_df, cur_bunch, bunch_size, i+bunch_size-1)
    elif func==weighted_bunch_mean:
      func(cur_stock_df, cur_bunch, bunch_size, i+bunch_size-1)
    i+=1
  return cur_stock_df

def bunch_mean(df, bunch, bunch_size, new_col_index):
  #creates a new column if not already exists.
  new_col = f"SMA{bunch_size}"
  if new_col not in df.columns:
        df[new_col] = None

  #calculates the mean of the current bunch.
  mean = bunch['High'].mean()

  #inputs the calculated mean in the corresponding column.
  df.loc[ new_col_index, f"SMA{bunch_size}"] = mean

def weighted_bunch_mean(df, bunch, bunch_size, new_col_index):
  weighted_mean=0
  index_sum=0
  new_col = f"WMA{bunch_size}"
  if new_col not in df.columns:
        df[new_col] = None

  #calculates the mean of the current bunch.
  for index, row in bunch.iterrows():
    index_sum += (index+1)
    weighted_mean += (index+1) * row['High']


  #inputs the calculated mean in the corresponding column.
  df.loc[ new_col_index, f"WMA{bunch_size}"] = (weighted_mean / index_sum)

def exponential_moving_average(df, n):
    # computes the exponential moving average (EMA) over n days
    alpha = 2 / (n + 1)
    ema_values = []       # list to store computed EMA values

    for i, price in enumerate(df["Close"]):
        if i == 0:
            ema_values.append(price)   # first EMA equals first price
        else:
            prev_ema = ema_values[-1]  # previous EMA
            ema_values.append(alpha * price + (1 - alpha) * prev_ema)  # EMA formula

    df[f"EMA_{n}"] = ema_values   # create new EMA column
    return df

# calculates WMA for a given window size using your weighted_bunch_mean function
def calc_wma_column(df, size):
    col = f"WMA{size}"
    df[col] = None

    for i in range(len(df)):
        # not enough rows to calculate WMA
        if i + 1 < size:
            continue

        # take the last 'size' rows
        bunch = df.iloc[i + 1 - size : i + 1]

        # use your function to place the result
        weighted_bunch_mean(df, bunch, size, i)

    return col

# Hull Moving Average
def hull_moving_average(df, n):
    half = int(n / 2)
    sqrt_n = int(np.sqrt(n))

    # calculate WMA(n)
    col_full = calc_wma_column(df, n)

    # calculate WMA(n/2)
    col_half = calc_wma_column(df, half)

    # create temporary values: 2*WMA(n/2) - WMA(n)
    df["HMA_temp"] = 2 * df[col_half] - df[col_full]

    # calculate WMA on the temporary values using sqrt(n)
    out_col = f"HMA{n}"
    df[out_col] = None

    for i in range(len(df)):
        # not enough rows for sqrt(n)
        if i + 1 < sqrt_n:
            continue

        # take the last sqrt(n) values
        bunch = df["HMA_temp"].iloc[i + 1 - sqrt_n : i + 1]

        # skip if there are missing values
        if bunch.isna().any():
            continue

        # compute WMA (same style as your function)
        weighted_mean = 0
        index_sum = 0

        for idx, val in enumerate(bunch):
            weight = idx + 1
            weighted_mean += weight * val
            index_sum += weight

        df.loc[i, out_col] = weighted_mean / index_sum

    return df

#finds the highest high price in the last n days for each row
def highest_high(df, window):
    df = df.copy()
    df[f'HH{window}'] = df['High'].rolling(window=window).max()
    return df

#finds the lowest low price in the last n days for each row
def lowest_low(df, window):
    df = df.copy()
    df[f'LL{window}'] = df['Low'].rolling(window=window).min()
    return df

def calculate_adx(df, n=14):

    df = df.copy()

    # Step 1: Price differences
    df['H_diff'] = df['High'].diff()
    df['L_diff'] = -df['Low'].diff()

    df['DM+'] = np.where((df['H_diff'] > df['L_diff']) & (df['H_diff'] > 0), df['H_diff'], 0)
    df['DM-'] = np.where((df['L_diff'] > df['H_diff']) & (df['L_diff'] > 0), df['L_diff'], 0)

    # Step 2: True Range
    df['TR1'] = df['High'] - df['Low']
    df['TR2'] = (df['High'] - df['Close'].shift()).abs()
    df['TR3'] = (df['Low'] - df['Close'].shift()).abs()
    df['TR'] = df[['TR1', 'TR2', 'TR3']].max(axis=1)

    # Step 3: Wilder smoothing
    df['TR_smooth'] = df['TR'].ewm(alpha=1/n, adjust=False).mean()
    df['DM+_smooth'] = df['DM+'].ewm(alpha=1/n, adjust=False).mean()
    df['DM-_smooth'] = df['DM-'].ewm(alpha=1/n, adjust=False).mean()

    # Step 4: DI+
    df['DI+'] = 100 * (df['DM+_smooth'] / df['TR_smooth'])
    df['DI-'] = 100 * (df['DM-_smooth'] / df['TR_smooth'])

    # Step 5: DX
    df['DX'] = 100 * ( (df['DI+'] - df['DI-']).abs() / (df['DI+'] + df['DI-']) )

    # Step 6: ADX
    df['ADX'] = df['DX'].ewm(alpha=1/n, adjust=False).mean()

    return df

"""# **Code:**"""

top10 = []
top10_dfs = []
i=0

for stock in sp100:
  if len(top10) == 10:
    break

  df = iter(stock, 20, bunch_mean)
  df = iter(df, 50, bunch_mean)
  df = iter(df, 100, bunch_mean)
  sma_filtering(df)

  df = iter(df, 20, weighted_bunch_mean)
  df = iter(df, 50, weighted_bunch_mean)
  df = iter(df, 100, weighted_bunch_mean)

  df = exponential_moving_average(df, 20)
  df = exponential_moving_average(df, 50)

  df = hull_moving_average(df, 20)
  df = hull_moving_average(df, 50)

  df = highest_high(df,20)
  df = lowest_low(df,20)

  df = calculate_adx(df, n=14)

  if(df.iloc[-1,-1]):
    top10.append(stock)
    top10_dfs.append(df)
  i+=1

top10

top10_dfs[0]

#check if the code works correctly
df_copy = df.copy()
df_copy = df_copy.head(40)
df_copy = highest_high(df_copy, 20)
df_copy = lowest_low(df_copy, 20)
print(df_copy)

i = 0
for df in top10_dfs:
    df['Date'] = pd.to_datetime(df['Date'])

    fig = go.Figure(data=go.Scatter(x=df['Date'], y=df['High'], mode='lines', name='Price'))
    fig.add_scatter(x=df['Date'], y=df['SMA20'], mode='lines', name='SMA 20')
    fig.add_scatter(x=df['Date'], y=df['SMA50'], mode='lines', name='SMA 50')
    fig.add_scatter(x=df['Date'], y=df['SMA100'], mode='lines', name='SMA 100')


    high_above_sma = df['High'].where(df['above_avg'], other=np.nan)

    fig.add_scatter(
        x=df['Date'],
        y=high_above_sma,
        mode='lines',
        line=dict(color='white', width=3, dash='dot'),
        name='Above all SMAs'
    )

    fig.update_layout(
        title=f"{top10[i]} Stock",
        xaxis_title="Date",
        yaxis_title="Price",
        template="plotly_dark"
    )
    fig.update_xaxes(tickformat="%m-%Y")
    fig.show()
    i += 1

i = 0
for df in top10_dfs:

    df['Date'] = pd.to_datetime(df['Date'])

    fig = go.Figure(data=go.Scatter(x=df['Date'], y=df['High'], mode='lines', name='Price', line=dict(color='white')))

    fig.add_scatter(x=df['Date'], y=df['SMA20'], mode='lines', name='SMA 20', line=dict(color='green'))
    fig.add_scatter(x=df['Date'], y=df['WMA20'], mode='lines', name='WMA 20', line=dict(color='blue'))
    fig.add_scatter(x=df['Date'], y=df['EMA_20'], mode='lines', name='EMA 20', line=dict(color='red'))
    fig.add_scatter(x=df['Date'], y=df['HMA20'], mode='lines', name='HMA 20', line=dict(color='cyan'))

    fig.update_layout(
        title=f"{top10[i]} Stock",
        xaxis_title="Date",
        yaxis_title="Price",
        template="plotly_dark"
    )

    fig.update_xaxes(tickformat="%m-%Y")
    fig.show()

    i += 1

i = 0
for df in top10_dfs:

    df['Date'] = pd.to_datetime(df['Date'])

    fig = go.Figure(data=go.Scatter(x=df['Date'], y=df['High'], mode='lines', name='Price', line=dict(color='white')))

    fig.add_scatter(x=df['Date'], y=df['SMA50'], mode='lines', name='SMA 50', line=dict(color='green'))
    fig.add_scatter(x=df['Date'], y=df['WMA50'], mode='lines', name='WMA 50', line=dict(color='blue'))
    fig.add_scatter(x=df['Date'], y=df['EMA_50'], mode='lines', name='EMA 50', line=dict(color='red'))
    fig.add_scatter(x=df['Date'], y=df['HMA50'], mode='lines', name='HMA 50', line=dict(color='cyan'))

    fig.update_layout(
        title=f"{top10[i]} Stock",
        xaxis_title="Date",
        yaxis_title="Price",
        template="plotly_dark"
    )

    fig.update_xaxes(tickformat="%m-%Y")
    fig.show()

    i += 1

from plotly.subplots import make_subplots
import plotly.graph_objects as go
import numpy as np

i = 0
for df in top10_dfs:

    df['Date'] = pd.to_datetime(df['Date'])
    df = df.replace({None: np.nan})  # make comparisons safe

    # price above ALL moving averages
    above_20 = (df['High'] > df['SMA20']) & (df['High'] > df['WMA20']) & (df['High'] > df['EMA_20']) & (df['High'] > df['HMA20'])
    high_above_20 = df['High'].where(above_20, other=np.nan)

    above_50 = (df['High'] > df['SMA50']) & (df['High'] > df['WMA50']) & (df['High'] > df['EMA_50']) & (df['High'] > df['HMA50'])
    high_above_50 = df['High'].where(above_50, other=np.nan)

    fig = make_subplots(rows=1, cols=2, subplot_titles=("Window 20", "Window 50"))

    # ================= Window 20 =================
    fig.add_trace(go.Scatter(x=df['Date'], y=df['High'], mode='lines', name='Price', line=dict(color='white')), row=1, col=1)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['SMA20'], mode='lines', name='SMA 20', line=dict(color='green')), row=1, col=1)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['WMA20'], mode='lines', name='WMA 20', line=dict(color='blue')), row=1, col=1)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['EMA_20'], mode='lines', name='EMA 20', line=dict(color='red')), row=1, col=1)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['HMA20'], mode='lines', name='HMA 20', line=dict(color='cyan')), row=1, col=1)

    # dashed white line
    fig.add_scatter(x=df['Date'], y=high_above_20, mode='lines',
                    line=dict(color='orange', width=3, dash='dot'),
                    name='Above all MAs 20', row=1, col=1)

    # ================= Window 50 =================
    fig.add_trace(go.Scatter(x=df['Date'], y=df['High'], mode='lines', name='Price', line=dict(color='white')), row=1, col=2)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['SMA50'], mode='lines', name='SMA 50', line=dict(color='green')), row=1, col=2)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['WMA50'], mode='lines', name='WMA 50', line=dict(color='blue')), row=1, col=2)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['EMA_50'], mode='lines', name='EMA 50', line=dict(color='red')), row=1, col=2)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['HMA50'], mode='lines', name='HMA 50', line=dict(color='cyan')), row=1, col=2)

    # dashed white line
    fig.add_scatter(x=df['Date'], y=high_above_50, mode='lines',
                    line=dict(color='orange', width=3, dash='dot'),
                    name='Above all MAs 50', row=1, col=2)

    fig.update_layout(title=f"{top10[i]} — Comparison: Window 20 vs Window 50", template="plotly_dark")
    fig.update_xaxes(tickformat="%m-%Y")

    fig.show()
    i += 1

i = 0
for df in top10_dfs:

    df['Date'] = pd.to_datetime(df['Date'])

    fig = go.Figure()

    fig.add_scatter(
        x=df['Date'],
        y=df['ADX'],
        mode='lines',
        name='ADX 14',
        line=dict(color='red')
    )

    fig.update_layout(
        title=f"{top10[i]} — ADX Indicator",
        xaxis_title="Date",
        yaxis_title="ADX Value",
        template="plotly_dark"
    )

    fig.update_xaxes(tickformat="%m-%Y")
    fig.show()

    i += 1